//
//  symbol.swift
//  serrano
//
//  Created by ZHONGHAO LIU on 7/23/17.
//  Copyright Â© 2017 ZHONGHAO LIU. All rights reserved.
//

import Foundation


/// Description
public enum SymbolType {
	case Tensor
	case Operator
	case Scalar
	
	/// If enum is data symbol
	///
	/// - Returns: return value description
	func isDataSymbol() -> Bool {
		return self == SymbolType.Tensor || self == SymbolType.Scalar
	}
}

/// The Data source of a data symbol
public enum SymbolDataSource {
	/// Symbol explicitly created by user and needs feeding from user, like Input of graph.
	case User
	
	/// Symbol gets data from a calculation result, so no need sfeeding from user.
	/// For example, output of operator symbols inside a graph.
	case Calculation
	
	/// Parameter data source.
	/// This measn a datay symbol's binded data is parameter.
	case Parameter
	
	/// Symbol has a default value but also can receive data from user,
	/// like some parameters of operators.
	case Default
	
	/// other cases
	case Other
}

/// Generate 6-length random string from `[a-zA-Z0-9]`
///
/// - Returns: ID
public func serranoSymbolUIDGenerate() -> String {
	let IDLength = 6
	let letters: NSString = "9876543210abcdefghijklMNOPQRSTUVWXYZ0123456789mnopqrstuvwxyzABCDEFGHIJKL0123456789"
	let len = UInt32(letters.length)
	
	var randomString = ""
	
	for _ in 0..<IDLength {
		randomString += String(letters.substring(with: NSRange(location: Int(arc4random_uniform(20120401)  % len), length: 1)))
	}
	
	return randomString
}

/**
The basic graph symbol protocol.
*/
public protocol GraphSymbol {
	
	/// Symbol type.
	var symbolType: SymbolType {get set}
	
	/// Unique ID for this symbol in a graph.
	///
	/// Note: This attribute is generated by Serrano. Usually, user should not touch this.
	var UID: String {get set}
	
	/// Readable label for this symbol.
	var symbolLabel: String {get set}
	
	/// Inbound list of `GraphSymbol` of this symbol
	var inBounds: [GraphSymbol]  {get set}
	
	/// Outbound list of `GraphSymbol` of this symbol
	var outBounds: [GraphSymbol] {get set}
	
	/// Generate a graph __ending__ with this symbol from its `inBounds` information recursively.
	func generateOutputGraph(_ label: String?) -> Graph
	
	/// Add new symbol to `inBounds`.
	/// Should check duplicate.
	func addToInBound(_ symbol: GraphSymbol)
	
	/// Add new symbol to `outBounds`
	/// Should check duplicate.
	func addToOutBound(_ symbol: GraphSymbol)
	
	/// Evaluate the symbol to get value.
	/// Returns maybe `nil`.
	///
	/// - Returns:  [DataSymbolSupportedDataType]
	func evaluate() -> [DataSymbolSupportedDataType]?
}

extension GraphSymbol {

	/// Generate a `ComputationGraph` object according to `inBounds` and `outBounds` information of this symbol.
	/// The generated graph ending with this symbol.
	///
	/// - Returns: A `ComputationGraph` object.
	public func generateOutputGraph(_ label: String? = nil) -> Graph {
		var graphLabel = label
		if graphLabel == nil { graphLabel = "ComputationGraph(Generate from symbol \(self.symbolLabel)[\(self.UID)])" }
		
		var symbolQueue = [GraphSymbol]()
		symbolQueue.append(self)
		
		let graph = ComputationGraph(graphLabel!)
		while !symbolQueue.isEmpty {
			// pop first
			let symbol = symbolQueue.first!
			symbolQueue.remove(at: 0)
			
			graph.addSymbols(symbol)
			symbolQueue.append(contentsOf: symbol.inBounds)
		}
		
		return graph
	}
}

public protocol DataSymbol: GraphSymbol {
	/// Data source
	var dataSource: SymbolDataSource {get set}
	
	/// Indicate if grads of this data symbol should be used to update itself.
	///
	/// ## updatable of DataSymbol V.S. enabledParameterUpdate of OperatorSymbol
	/// Both attribute controls data updating in backward training.
	/// `updatable` of a data symbol controls whether updating this symbol's binded data,
	/// while `enabledParameterUpdate` controls whether updating operator symbol's inbounds data symbols.
	/// If `enabledParameterUpdate` is `false`, Serrano will ignore `updatable` attributes of
	/// all data symbols in this operator symbol's inbounds.
	/// So user can think `enabledParameterUpdate` has high priority over `updatable` on controlling.
	var updatable: Bool {get set}
	
	/// This attribute hold the grad of this data symbol in this epoch training.
	/// This grad value is chained value (i.e. grad of final output of the grpah against this data)
	///
	/// - Note: `currentGrad` will be added to `historyGrads` at the end of each backward training.
	var currentGrad: DataSymbolSupportedDataType? {get set}
	
	/// Binded data
	var bindedData: DataSymbolSupportedDataType? {get set}
	
	/// Bind data to data symbol
	///
	/// - Parameter data: data to bind
	/// - Returns: if binded successfully
	func bindData(_ data:DataSymbolSupportedDataType) -> Bool
	
	/// This function used to update a data symbol's value and grad during backward.
	///
	/// - Parameters:
	///   - optimizer: optimizer
	///   - gradValue: this epoch calculated value
	///   - upGrads: up grads from backward chain
	mutating func backwardUpdate(_ optimizer: Optimizer, gradValue: DataSymbolSupportedDataType, upGrads:[DataSymbolSupportedDataType])
}

extension DataSymbol {
	
	/// This function used to update a data symbol's value during backward.
	///
	/// 1. Calculate chained grads
	/// 2. Use optimizer updaing bined value
	/// 3. Store this epoch's grad
	///
	/// - Parameters:
	///   - optimizer: optimizer
	///   - gradValue: this epoch calculated value
	///   - upGrads: up grads from backward chain
	public mutating func backwardUpdate(_ optimizer: Optimizer, gradValue: DataSymbolSupportedDataType, upGrads:[DataSymbolSupportedDataType])  {
		// chained grads
		if self.symbolType == SymbolType.Scalar {
			// Oprator takes in tensors and outputs tensors
            // and I cannot think of any operator where a scalar parameter is trainable.
			// So for scalar symbol, I doubt if we needs to calcualte its grads....
			// FIXME: If you think it is not neccessary.
			let gradValueFloat = (gradValue as! SupportedScalarDataType).floatValue
			var gradValue:Float = 0.0
			for upGrad in upGrads {
				if upGrad is Tensor {
					// tensor up grad, do reduce sum
					let upGradTensor = upGrad as! Tensor
					let gradTensor = Tensor(repeatingValue: 0.0, tensorShape: TensorShape(dataType: .float, shape: [1]))
					let reduceOp = ReduceSumOperator(inputTensors: [upGradTensor], outputTensors: [gradTensor],
													 axis:Array(0..<upGradTensor.rank))
					reduceOp.disableInputOutputCheck = true
					reduceOp.compute(OperatorComputationMode.GPU)
					gradValue += gradValueFloat * gradTensor[0]
				} else {
					gradValue += gradValueFloat * (upGrad as! SupportedScalarDataType).floatValue
				}
			}
			optimizer.updateParameter(self, gradValue: gradValue)
			self.currentGrad = gradValue
		} else {
			let finalGrad = (gradValue as! Tensor) // We force here cause it should be always outputing tensor from tensor input
			for upGrad in upGrads {
				finalGrad &* (upGrad as! Tensor)
			}
			optimizer.updateParameter(self, gradValue: finalGrad)
			// [Notice] Here we cannot just do `self.currentGrad = finalGrad` cause they are both tensor objects.
			// The assignment will change the reference of self.currentGrad and may lead to unknown results.
			self.currentGrad!.tensorValue.copyValues(finalGrad)
		}
	}
}

/**
Symbol represents a scalar variable.
*/
public protocol ScalarSymbol: DataSymbol {
	/// Data type
	var dataType: TensorDataType {get set}
}

/// Default implementation of `evaluate() -> [DataSymbolSupportedDataType]?`
extension ScalarSymbol {
	public func evaluate() -> [DataSymbolSupportedDataType]? {
		if bindedData == nil {
			return nil
		} else {
			return [self.bindedData!]
		}
	}
}

/**
Symbol represents a tensor object
*/
public protocol TensorSymbol: DataSymbol {
	/// Shpe of this tensor symbol
	var shape: TensorShape {get set}
}

/// Default implementation of `evaluate() -> Tensor`
extension TensorSymbol {
	public func evaluate(_ mode: OperatorComputationMode = .GPU) ->  [DataSymbolSupportedDataType]? {
		let graph = self.generateOutputGraph()
		graph.forward(mode: mode)
		return [self.bindedData!]
	}
}

/**
Symbol represent an operator calcualtion
*/
public protocol OperatorSymbol: GraphSymbol {
	/// Input symbols for this operator
	///
	/// - Note: symbols in this attribute should also be included in `inBounds`
	var inputSymbols: [TensorSymbol] {get set}
	
	/// Input shapes tensor symbols in `inputSymbols`
	var inputTensorShapes: [TensorShape] {get set}

	/// Parameters (weights, bias etc.) symbols for this operator.
	/// For operator having no params, this should be an empty array.
	///
	/// - Note: symbols in this attribute should also be included in `inBounds`
	var paramSymbols: [DataSymbol] {get set}
	
	/// The operator instance
	var serranoOperator: ComputableOperator {get set}
	
	/// Control if update asscoiated operator's parameter
	///
	/// ## updatable of DataSymbol V.S. enabledParameterUpdate of OperatorSymbol
	/// Both attribute controls data updating in backward training.
	/// `updatable` of a data symbol controls whether updating this symbol's binded data,
	/// while `enabledParameterUpdate` controls whether updating operator symbol's inbounds data symbols.
	/// If `enabledParameterUpdate` is `false`, Serrano will ignore `updatable` attributes of
	/// all data symbols in this operator symbol's inbounds.
	/// So user can think `enabledParameterUpdate` has high priority over `updatable` on controlling.
	var enabledParameterUpdate: Bool {get set}
	
	/// Get output symbols of this operator
	///
	/// - Returns: Array of SerranoTensorSymbol.
	func outputSymbols() -> [TensorSymbol]

	/// Add to `paramSymbols`
	///
	/// - Parameter symbol: new symbol
	func addToParamSymbols(_ symbol: GraphSymbol)
	
	/// Get grads on any inbounds symbol
	///
	/// - Parameter inputSymbol:
	/// - Returns: SupportedGradsDataType
	func gradsOnInput(_ inputSymbol: DataSymbol) -> DataSymbolSupportedDataType
	
	/// Get corresponding inbound symbol for a label following rule in `Operator` method
	/// `gradCompute(_:)`.
	///
	/// - Parameter label: label
	/// - Returns: DataSymbol
	func inboundSymbolForGradLabel(_ label: String) -> DataSymbol?
	
	/// For a given `symbol` in inbounds, return a list of output symbols that
	/// it involves with calculation.
	///
	/// - Parameter symbol: target symbol
	/// - Returns: list of output symbol
	func gradRelatedOutputSymbols(onInboundSymbol symbol: DataSymbol) -> [DataSymbol]
}

/// Default implementation of `evaluate() -> [Tensor]`
extension OperatorSymbol {
	public func evaluate(_ mode: OperatorComputationMode = .GPU) -> [DataSymbolSupportedDataType]? {
		let graph = self.generateOutputGraph()
		graph.forward(mode: mode)
		return self.serranoOperator.outputTensors! as [DataSymbolSupportedDataType]
	}
	
	/// Add to `paramSymbols`
	///
	/// - Parameter symbol: new symbol
	public func addToParamSymbols(_ symbol: GraphSymbol) {
		if !self.paramSymbols.contains { (graphSymbol) -> Bool in
			return graphSymbol.UID == symbol.UID
			} {
			var o = self as OperatorSymbol
			guard symbol is DataSymbol else {
				SerranoLogging.errorLogging(message: "Symbol argument is not a DataSymbol type.",
				                            file: "\(#file)", function:  "\(#function)", line:  "\(#line)")
				fatalError("Fatalerror raised by Serrano. Check log for details")
			}
			o.paramSymbols.append(symbol as! DataSymbol)
		}
	}
	
	/// Get grads on any inbounds symbol.
	/// Call attached operator's `gradCompute(_:, :)` to get grads.
	/// Use return tensor's label to identify corresponding input datasymbol.
	///
	/// ## Identify corresponding input
	/// The tensor label of returned tensors could be used to identify its correspoding input
	/// following below rules:
	/// - __Input tensor__. `input_{i}` where `i` is the corresponding input tensor's index in `inputTensors`
	///	- __Parameter__. The parameter's name.
	///
	/// - Note: If `inputSymbol` does not belong to this operator symbol.
	///         `fatalError()` raised.
	///
	/// - Parameter inputSymbol:
	/// - Returns: SupportedGradsDataType
	public func gradsOnInput(_ inputSymbol: DataSymbol) -> DataSymbolSupportedDataType {
		// check belonging
		guard (self.inBounds.contains {$0.UID == inputSymbol.UID}) else {
			SerranoLogging.errorLogging(message: "Symbol argument is not a DataSymbol type.",
			                            file: "\(#file)", function:  "\(#function)", line:  "\(#line)")
			fatalError("Fatalerror raised by Serrano. Check log for details")
		}
		
		let label:String
		if (self.inputSymbols.contains {inputSymbol.UID == $0.UID}) {
			label = "input_\(self.inputSymbols.index {$0.UID == inputSymbol.UID}!)"
		} else {
			// We just use symbol's label her cause param symbol is generated by operator's paramSymbols() function.
			// This function will assgin proper labels.
			label = inputSymbol.symbolLabel
		}
		
		let grad = self.serranoOperator.gradCompute(.GPU).filter { $0.key == label}.first?.value
		guard grad != nil else {
			SerranoLogging.errorLogging(message: "Unexpected error. Could not find grads for target input.",
			                            file: "\(#file)", function:  "\(#function)", line:  "\(#line)")
			fatalError("Fatalerror raised by Serrano. Check log for details")
		}
		return grad!
	}
	
	/// Get inbound data symbol for target label.
	///
	/// ## Identify corresponding input
	/// The returned label of data could be used to identify its correspoding input
	/// following below rules:
	/// - __Input tensor__. `input_{i}` where `i` is the corresponding input tensor's index in `inputTensors`
	///	- __Parameter__. The parameter's name.
	///
	/// - Note: may return `nil`
	///
	/// - Parameter label: label
	/// - Returns: symbol
	public func inboundSymbolForGradLabel(_ label: String) -> DataSymbol? {
		let symbol: DataSymbol?
		if label.contains("input") {
			// input tensor symbol
			symbol = self.inputSymbols[Int(label.split(separator: "_").last!)!]
		} else {
			// parameter data symbol
			symbol = self.paramSymbols.filter {$0.symbolLabel == label}.first
		}
		return symbol
	}
	
	/// For a given `symbol` in inbounds, return a list of output symbols that
	/// it involves with calculation.
	///
	/// - Parameter symbol: target symbol
	/// - Returns: list of output symbol
	public func gradRelatedOutputSymbols(onInboundSymbol symbol: DataSymbol) -> [DataSymbol] {
		var symbols = [DataSymbol]()
		if self.serranoOperator.mapType == OperatorMappingType.Constant {
			symbols.append(self.outBounds[0] as! DataSymbol)
		} else {
			let index = self.inputSymbols.index(where: {$0.UID == symbol.UID})
			if index != nil {
				// input symbol
				symbols.append(self.outBounds[index!] as! DataSymbol)
			} else {
				// param symbols, all output
				symbols.append(contentsOf: self.outBounds[index!] as! [DataSymbol])
			}
		}
		return symbols
	}
}

